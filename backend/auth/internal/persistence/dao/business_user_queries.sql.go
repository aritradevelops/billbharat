// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: business_user_queries.sql

package dao

import (
	"context"

	"github.com/google/uuid"
)

const createBusinessUser = `-- name: CreateBusinessUser :one
INSERT INTO "business_users" (
    user_id, business_id, role, created_by
) VALUES (
    $1, $2, $3, $4
) RETURNING user_id, business_id, role, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by
`

type CreateBusinessUserParams struct {
	UserID     uuid.UUID `json:"user_id"`
	BusinessID uuid.UUID `json:"business_id"`
	Role       string    `json:"role"`
	CreatedBy  uuid.UUID `json:"created_by"`
}

func (q *Queries) CreateBusinessUser(ctx context.Context, arg CreateBusinessUserParams) (BusinessUser, error) {
	row := q.db.QueryRow(ctx, createBusinessUser,
		arg.UserID,
		arg.BusinessID,
		arg.Role,
		arg.CreatedBy,
	)
	var i BusinessUser
	err := row.Scan(
		&i.UserID,
		&i.BusinessID,
		&i.Role,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const deleteBusinessUser = `-- name: DeleteBusinessUser :one
DELETE FROM "business_users" WHERE user_id = $1 AND business_id = $2 AND deleted_at IS NULL RETURNING user_id, business_id, role, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by
`

type DeleteBusinessUserParams struct {
	UserID     uuid.UUID `json:"user_id"`
	BusinessID uuid.UUID `json:"business_id"`
}

func (q *Queries) DeleteBusinessUser(ctx context.Context, arg DeleteBusinessUserParams) (BusinessUser, error) {
	row := q.db.QueryRow(ctx, deleteBusinessUser, arg.UserID, arg.BusinessID)
	var i BusinessUser
	err := row.Scan(
		&i.UserID,
		&i.BusinessID,
		&i.Role,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const findBusinessesByUserID = `-- name: FindBusinessesByUserID :many
SELECT bu.user_id, bu.business_id, bu.role, bu.created_at, bu.created_by, bu.updated_at, bu.updated_by, bu.deleted_at, bu.deleted_by, b.id, b.name, b.description, b.logo, b.industry, b.primary_currency, b.owner_id, b.currencies, b.created_at, b.created_by, b.updated_at, b.updated_by, b.deleted_at, b.deleted_by FROM "business_users" AS bu
LEFT JOIN "businesses" AS b ON bu.business_id = b.id AND b.deleted_at IS NULL
WHERE bu.user_id = $1 AND bu.deleted_at IS NULL
`

type FindBusinessesByUserIDRow struct {
	BusinessUser BusinessUser `json:"business_user"`
	Business     Business     `json:"business"`
}

func (q *Queries) FindBusinessesByUserID(ctx context.Context, userID uuid.UUID) ([]FindBusinessesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, findBusinessesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindBusinessesByUserIDRow
	for rows.Next() {
		var i FindBusinessesByUserIDRow
		if err := rows.Scan(
			&i.BusinessUser.UserID,
			&i.BusinessUser.BusinessID,
			&i.BusinessUser.Role,
			&i.BusinessUser.CreatedAt,
			&i.BusinessUser.CreatedBy,
			&i.BusinessUser.UpdatedAt,
			&i.BusinessUser.UpdatedBy,
			&i.BusinessUser.DeletedAt,
			&i.BusinessUser.DeletedBy,
			&i.Business.ID,
			&i.Business.Name,
			&i.Business.Description,
			&i.Business.Logo,
			&i.Business.Industry,
			&i.Business.PrimaryCurrency,
			&i.Business.OwnerID,
			&i.Business.Currencies,
			&i.Business.CreatedAt,
			&i.Business.CreatedBy,
			&i.Business.UpdatedAt,
			&i.Business.UpdatedBy,
			&i.Business.DeletedAt,
			&i.Business.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUsersByBusinessID = `-- name: FindUsersByBusinessID :many
SELECT bu.user_id, bu.business_id, bu.role, bu.created_at, bu.created_by, bu.updated_at, bu.updated_by, bu.deleted_at, bu.deleted_by, u.id, u.human_id, u.name, u.email, u.dp, u.email_verified, u.phone, u.phone_verified, u.created_at, u.created_by, u.updated_at, u.updated_by, u.deactivated_at, u.deactivated_by, u.deleted_at, u.deleted_by FROM "business_users" AS bu
LEFT JOIN "users" AS u ON bu.user_id = u.id AND u.deleted_at IS NULL
WHERE bu.business_id = $1 AND bu.deleted_at IS NULL
`

type FindUsersByBusinessIDRow struct {
	BusinessUser BusinessUser `json:"business_user"`
	User         User         `json:"user"`
}

func (q *Queries) FindUsersByBusinessID(ctx context.Context, businessID uuid.UUID) ([]FindUsersByBusinessIDRow, error) {
	rows, err := q.db.Query(ctx, findUsersByBusinessID, businessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUsersByBusinessIDRow
	for rows.Next() {
		var i FindUsersByBusinessIDRow
		if err := rows.Scan(
			&i.BusinessUser.UserID,
			&i.BusinessUser.BusinessID,
			&i.BusinessUser.Role,
			&i.BusinessUser.CreatedAt,
			&i.BusinessUser.CreatedBy,
			&i.BusinessUser.UpdatedAt,
			&i.BusinessUser.UpdatedBy,
			&i.BusinessUser.DeletedAt,
			&i.BusinessUser.DeletedBy,
			&i.User.ID,
			&i.User.HumanID,
			&i.User.Name,
			&i.User.Email,
			&i.User.Dp,
			&i.User.EmailVerified,
			&i.User.Phone,
			&i.User.PhoneVerified,
			&i.User.CreatedAt,
			&i.User.CreatedBy,
			&i.User.UpdatedAt,
			&i.User.UpdatedBy,
			&i.User.DeactivatedAt,
			&i.User.DeactivatedBy,
			&i.User.DeletedAt,
			&i.User.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
